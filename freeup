#!/usr/bin/perl -w
use strict;

use bigint;

use Fcntl;
use File::Basename;
use File::Find;
use NDBM_File;

my %file_history; # (filename => last timestamp when we asked the user about it)

my @file_score; # array of [filename, size] arrayrefs

my $best_size = 0;  # Size of best range so far
my $best_index = undef; # Index of beginning of best range so far
my $best_end_index = undef; # Index of end (exclusive) of best range so far

my $this_index = 0; # Index of beginning of current range
my $this_size = 0; # Size of current range

my $index = 0;

my $start_time = time(); # Timestamp of when script started running
my $REASK_TIME = 60 * 60 * 24 * 30; # How long to wait before reasking about a file

# Callback for File::Find
sub wanted
{
    if (-f $_)
    {
	my $this_history = $file_history{$File::Find::name};
	my $size = -s $File::Find::name;

	if ($this_history and $this_history > $start_time - $REASK_TIME)
	{
	    # We've found a file that's been looked at in recent history
	    
	    if ($this_size > $best_size)
	    {
		# We've broken the record for the best range
		$best_index = $this_index;
		$best_end_index = $index + 1;
		$best_size = $this_size;
	    }

	    # Reset everything, we start a new range on the next item
	    $this_index = $index + 1;
	    $this_size = 0;
	}
	else
	{
	    # We're just continuing the current range
	    $this_size += $size;
	}
	
	$index += 1;
	push @file_score, [$File::Find::name, $size];
    }
}

sub finish_file_iter
{
    if ($this_size > $best_size)
    {
	$best_index = $this_index;
	$best_end_index = $index;
	$best_size = $this_size;
    }
}

sub find_best_midpoint
{
    my $remaining_size = $best_size / 2;
    for my $index ($best_index .. $best_end_index-1)
    {
	$remaining_size -= $file_score[$index][1];
	return $index if ($remaining_size <= 0)
    }

    die "Can't happen";
}

# Convert a file size to a friendly representation
sub human_filesize
{
    my ($size) = @_;
    if ($size > 1024*1024*1024)
    {
	return int($size/1024/1024/1024) . "G";
    }
    elsif ($size > 1024*1024)
    {
	return int($size/1024/1024) . "M";
    }
    elsif ($size > 1024)
    {
	return int($size/1024) . "K";
    }
    else
    {
	return $size;
    }
}

die "Need to specify target directory" unless @ARGV;

mkdir "$ENV{HOME}/.freeup";
tie(%file_history,
    'NDBM_File',
    "$ENV{HOME}/.freeup/file_history",
    O_RDWR | O_CREAT,
    0666)
    or die "$0: Tie failed: $!";

find(\&wanted, @ARGV);
finish_file_iter();

print "Best range is $best_index, end $best_end_index, out of $index\n";
print "Range begin: $file_score[$best_index][0]\n";
print "Range end: $file_score[$best_end_index-1][0]\n";
print "Range size: ", human_filesize($best_size), "\n";

my $best_midpoint = find_best_midpoint();
print "Midpoint is $best_midpoint: $file_score[$best_midpoint][0]\n";
my $best_file = $file_score[$best_midpoint][0];

print human_filesize($file_score[$best_midpoint][1]), "  $file_score[$best_midpoint][0]\n";

my $best_dir = dirname($best_file);

while($best_dir ne '/')
{
    my $best_dir_size = 0;
    for my $file_iter (@file_score)
    {
	my $name = $file_iter->[0];

	my $iter_dir = substr($name, 0, length($best_dir)+1);
	if ($iter_dir eq "$best_dir/")
	{
	    $best_dir_size += $file_iter->[1];
	}
    }

    print human_filesize($best_dir_size), "  $best_dir/\n";

    $best_dir = dirname($best_dir);
    #print "  Testing $best_dir\n";
    #print "    ", substr($file_score[$best_index][0], 0, length($best_dir)+1), " <=> ", "$best_dir/", "\n";
    #print "    ", substr($file_score[$best_end_index][0], 0, length($best_dir)+1), " <=> ", "$best_dir/", "\n";
    last if $best_end_index >= $index;
    last if substr($file_score[$best_index][0], 0, length($best_dir)+1) eq "$best_dir/" and
	substr($file_score[$best_end_index][0], 0, length($best_dir)+1) eq "$best_dir/";
    #print "    passed\n";
}

$file_history{$best_file} = time();

untie(%file_history);
