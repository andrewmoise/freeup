#!/usr/bin/perl -w
use strict;

use bigint;

use Fcntl;
use File::Basename;
use File::Find;
use NDBM_File;

my %file_history; # (filename => last timestamp when we asked the user about it)

my @file_score; # array of [filename, size] arrayrefs

my $best_size = 0;  # Size of best range so far

my $best_index = undef; # Index of beginning of best range so far
my $best_end_index = undef; # Index of end (exclusive) of best range so far

my $best_index_desc = undef;
my $best_end_index_desc = undef;

my $this_index = 0; # Index of beginning of current range
my $this_size = 0; # Size of current range

my $index = 0;

my $start_time = time(); # Timestamp of when script started running

my $topdev; # Device number of top level directory

# Callback for File::Find
sub wanted
{
    my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,
	$atime, $mtime, $ctime, $blksize, $blocks) = lstat($File::Find::name);

    if (-f $_)
    {
	my $this_history = $file_history{$File::Find::name};
	my $should_break_range = 0;
	my $examined_desc = "Unexamined";

	if ($this_history)
	{
	    # We've shown this file before. We need to decide
	    # stochastically if we've shown it recently enough that we
	    # should break the range we're currently adding up.

	    my $examined_time = $this_history - $ctime;
	    my $unexamined_time = $start_time - $this_history;
	    $examined_desc = int($unexamined_time * 100 /
				 ($examined_time + $unexamined_time))
		. '% expired';

	    # Cap unexamined time at 6 months, so that regardless of
	    # age we present files every so often without waiting
	    # years
	    if ($unexamined_time > 60*60*24*30*6) {
		$unexamined_time = 60*60*24*30*6;
	    }
	    
	    if ($examined_time > 0 and
		$unexamined_time > 0 and
		rand($examined_time + $unexamined_time) < $examined_time)
	    {
		# We've examined this file somewhat recently, so count
		# the range that contains it as two smaller ranges of
		# unexamined files (i.e. "break" the range into two)
		$should_break_range = 1;
	    }
	    else
	    {
		# We just "expired" a file that used to break the
		# range, but hasn't been examined in a while. Treat it
		# as unexamined again. This also happens under some
		# odd "can't happen" conditions (if one of the times
		# is negative).
		undef $file_history{$File::Find::name};
		$should_break_range = 0;
	    }

	}

	if ($should_break_range)
	{
	    # We want to stop the current range, and start a new one
	    # after the current point.
	    
	    if ($this_size > $best_size)
	    {
		# We've broken the record for the best range
		$best_index = $this_index;
		$best_end_index = $index;
		$best_size = $this_size;

		if ($best_index == 0)
		{
		    $best_index_desc = "Beginning of scan";
		}
		else
		{
		    $best_index_desc = "$file_score[$best_index-1][0] ("
			. human_filesize($file_score[$best_index-1][1])
			. ", $file_score[$best_index-1][2])";
		}

		$best_end_index_desc = "$File::Find::name ("
		    . human_filesize($size + $blksize)
		    . ", $examined_desc)";
	    }

	    # Reset everything, we start a new range on the next item
	    $this_index = $index + 1;
	    $this_size = 0;
	}
	else
	{
	    # We're just continuing the current range
	    $this_size += $size + $blksize;
	}
	
	$index += 1;
	push @file_score, [$File::Find::name, $size + $blksize, $examined_desc];
    }
    elsif (-d $_)
    {
	$File::Find::prune = 1 if ($dev != $topdev);
    }
}

sub finish_file_iter
{
    if ($this_size > $best_size)
    {
	$best_index = $this_index;
	$best_end_index = $index;
	$best_size = $this_size;

	if ($best_index == 0)
	{
	    $best_index_desc = "Beginning of scan";
	}
	else
	{
	    $best_index_desc = "$file_score[$best_index-1][0] ("
		. human_filesize($file_score[$best_index-1][1])
		. ", $file_score[$best_index-1][2])";
	}

	$best_end_index_desc = "End of scan";
    }
}

sub find_file_in_best_range
{
    my $remaining_size = int(rand($best_size)) + 1;
    for my $index ($best_index .. $best_end_index-1)
    {
	$remaining_size -= $file_score[$index][1];
	return $index if ($remaining_size <= 0)
    }

    die "Can't happen";
}

# Convert a file size to a friendly representation
sub human_filesize
{
    my ($size) = @_;
    if ($size > 1024*1024*1024)
    {
	return int($size/1024/1024/1024) . "G";
    }
    elsif ($size > 1024*1024)
    {
	return int($size/1024/1024) . "M";
    }
    elsif ($size > 1024)
    {
	return int($size/1024) . "K";
    }
    else
    {
	return $size;
    }
}

die "Need to specify target directory" unless @ARGV;

mkdir "$ENV{HOME}/.freeup";
tie(%file_history,
    'NDBM_File',
    "$ENV{HOME}/.freeup/file_history",
    O_RDWR | O_CREAT,
    0666)
    or die "$0: Tie failed: $!";

for my $dir (@ARGV)
{
    my ($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($dir);
    $topdev = $dev;

    find(\&wanted, $dir);
}
finish_file_iter();

print "Best range is $best_index, end $best_end_index, out of $index\n";
print "Range begin: $best_index_desc\n";
print "Range end: $best_end_index_desc\n";
print "Range size: ", human_filesize($best_size), "\n";

my $best_midpoint = find_file_in_best_range();
print "Chosen file is $best_midpoint: $file_score[$best_midpoint][0]\n";
my $best_file = $file_score[$best_midpoint][0];

print human_filesize($file_score[$best_midpoint][1]), "  $file_score[$best_midpoint][0]\n";

my $best_dir = dirname($best_file);

while($best_dir ne '/')
{
    my $best_dir_size = 0;
    for my $file_iter (@file_score)
    {
	my $name = $file_iter->[0];

	my $iter_dir = substr($name, 0, length($best_dir)+1);
	if ($iter_dir eq "$best_dir/")
	{
	    $best_dir_size += $file_iter->[1];
	}
    }

    print human_filesize($best_dir_size), "  $best_dir/\n";

    $best_dir = dirname($best_dir);
    #print "  Testing $best_dir\n";
    #print "    ", substr($file_score[$best_index][0], 0, length($best_dir)+1), " <=> ", "$best_dir/", "\n";
    #print "    ", substr($file_score[$best_end_index][0], 0, length($best_dir)+1), " <=> ", "$best_dir/", "\n";
    last if $best_end_index >= $index;
    last if substr($file_score[$best_index][0], 0, length($best_dir)+1) eq "$best_dir/" and
	substr($file_score[$best_end_index][0], 0, length($best_dir)+1) eq "$best_dir/";
    #print "    passed\n";
}

$file_history{$best_file} = time();

untie(%file_history);
