#!/usr/bin/perl -w
use strict;

use bigint;

use Fcntl;
use File::Basename;
use File::Find;
use NDBM_File;

my %file_history; # (filename => last timestamp when we asked the user about it)

my @file_score; # array of [filename, size] arrayrefs

my $best_size = 0;  # Size of best range so far
my $best_index = undef; # Index of beginning of best range so far
my $best_length = undef; # Length of best range so far

my $this_index = 0; # Index of beginning of current range
my $this_size = 0; # Size of current range

my $index = 0;

my $start_time = time(); # Timestamp of when script started running
my $REASK_TIME = 60 * 60 * 24 * 30; # How long to wait before reasking about a file

# Callback for File::Find
sub wanted
{
    if (-f $_)
    {
	my $this_history = $file_history{$File::Find::name};
	my $size = -s $File::Find::name;

	if ($this_history and $this_history > $start_time - $REASK_TIME)
	{
	    # We've found a file that's been looked at in recent history
	    
	    if ($this_size > $best_size)
	    {
		# We've broken the record for the best range
		$best_index = $this_index;
		$best_length = $index + 1 - $this_index;
		$best_size = $this_size;
	    }

	    # Reset everything, we start a new range on the next item
	    $this_index = $index + 1;
	    $this_size = 0;
	}
	else
	{
	    # We're just continuing the current range
	    $this_size += $size;
	}
	
	$index += 1;
	push @file_score, [$File::Find::name, $size];
    }
}

sub finish_file_iter
{
    if ($this_size > $best_size)
    {
	$best_index = $this_index;
	$best_length = $index + 1 - $this_index;
	$best_size = $this_size;
    }
}

sub find_best_midpoint
{
    my $remaining_size = $best_size / 2;
    for my $index ($best_index .. $best_index+$best_length-1)
    {
	$remaining_size -= $file_score[$index][1];
	return $index if ($remaining_size <= 0)
    }

    die "Can't happen";
}

# Convert a file size to a friendly representation
sub human_filesize
{
    my ($size) = @_;
    if ($size > 1024*1024*1024)
    {
	return int($size/1024/1024/1024) . "G";
    }
    elsif ($size > 1024*1024)
    {
	return int($size/1024/1024) . "M";
    }
    elsif ($size > 1024)
    {
	return int($size/1024) . "K";
    }
    else
    {
	return $size;
    }
}

die "Need to specify target directory" unless @ARGV;

mkdir "$ENV{HOME}/.freeup";
tie(%file_history,
    'NDBM_File',
    "$ENV{HOME}/.freeup/file_history",
    O_RDWR | O_CREAT,
    0666)
    or die "$0: Tie failed: $!";

find(\&wanted, @ARGV);
finish_file_iter();

print "Best range is $best_index, len $best_length, out of $index\n";

my $best_midpoint = find_best_midpoint();
print "Midpoint is $best_midpoint\n";
my $best_file = $file_score[$best_midpoint][0];

print human_filesize($file_score[$best_midpoint][1]), "  $file_score[$best_midpoint][0]\n";

my $best_dir_size = 0;
my $best_dir_and_subdirs_size = 0;

my $best_dir = dirname($best_file) . '/';
my $best_dir_len = length($best_dir);
for my $file_iter (@file_score)
{
    my $name = $file_iter->[0];

    my $iter_dir = substr($name, 0, $best_dir_len);
    if ($iter_dir eq $best_dir)
    {
	my $size = $file_iter->[1];
	$best_dir_and_subdirs_size += $size;

	my $other_part = substr($name, $best_dir_len);
	if ($other_part !~ /\//)
	{
	    $best_dir_size += $size;
	}
    }
}

print human_filesize($best_dir_size), "  $best_dir\*\n";
print human_filesize($best_dir_and_subdirs_size), "  $best_dir...\n";

$file_history{$best_file} = time();

untie(%file_history);
