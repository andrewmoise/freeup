#!/usr/bin/perl -w
use strict;

use bigint;

use Fcntl;
use File::Basename;
use File::Find;
use NDBM_File;

my %file_history; # (filename => last timestamp when we asked the user about it)

my @file_score; # array of [filename, size] arrayrefs

my $best_size = 0;  # Size of best range so far
my $best_index = undef; # Index of beginning of best range so far
my $best_end_index = undef; # Index of end (exclusive) of best range so far

my $this_index = 0; # Index of beginning of current range
my $this_size = 0; # Size of current range

my $index = 0;

my $start_time = time(); # Timestamp of when script started running

my $topdev; # Device number of top level directory

# Callback for File::Find
sub wanted
{
    my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,
	$atime, $mtime, $ctime, $blksize, $blocks) = lstat($File::Find::name);

    if (-f $_)
    {
	my $this_history = $file_history{$File::Find::name};

	my $should_break_range = 0;

	if ($this_history)
	{
	    # We've shown this file before. We need to decide
	    # stochastically if we've shown it recently enough that we
	    # should break the range we're currently adding up.

	    my $examined_time = $this_history - $ctime;
	    my $unexamined_time = $start_time - $this_history;

	    if ($examined_time <= 0)
	    {
		$should_break_range = 0;
	    }
	    elsif ($unexamined_time <= 0)
	    {
		$should_break_range = 1;
	    }
	    elsif (rand($examined_time + $unexamined_time) < $examined_time)
	    {
		$should_break_range = 1;
	    }
	}

	if ($should_break_range)
	{
	    # We want to stop the current range, and start a new one
	    # after the current point.
	    
	    if ($this_size > $best_size)
	    {
		# We've broken the record for the best range
		$best_index = $this_index;
		$best_end_index = $index + 1;
		$best_size = $this_size;
	    }

	    # Reset everything, we start a new range on the next item
	    $this_index = $index + 1;
	    $this_size = 0;
	}
	else
	{
	    # We're just continuing the current range
	    $this_size += $size;
	}
	
	$index += 1;
	push @file_score, [$File::Find::name, $size];
    }
    elsif (-d $_)
    {
	$File::Find::prune = 1 if ($dev != $topdev);
    }
}

sub finish_file_iter
{
    if ($this_size > $best_size)
    {
	$best_index = $this_index;
	$best_end_index = $index;
	$best_size = $this_size;
    }
}

sub find_best_midpoint
{
    my $remaining_size = int(rand($best_size)) + 1;
    for my $index ($best_index .. $best_end_index-1)
    {
	$remaining_size -= $file_score[$index][1];
	return $index if ($remaining_size <= 0)
    }

    die "Can't happen";
}

# Convert a file size to a friendly representation
sub human_filesize
{
    my ($size) = @_;
    if ($size > 1024*1024*1024)
    {
	return int($size/1024/1024/1024) . "G";
    }
    elsif ($size > 1024*1024)
    {
	return int($size/1024/1024) . "M";
    }
    elsif ($size > 1024)
    {
	return int($size/1024) . "K";
    }
    else
    {
	return $size;
    }
}

die "Need to specify target directory" unless @ARGV;

mkdir "$ENV{HOME}/.freeup";
tie(%file_history,
    'NDBM_File',
    "$ENV{HOME}/.freeup/file_history",
    O_RDWR | O_CREAT,
    0666)
    or die "$0: Tie failed: $!";

for my $dir (@ARGV)
{
    my ($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($dir);
    $topdev = $dev;

    find(\&wanted, $dir);
}
finish_file_iter();

print "Best range is $best_index, end $best_end_index, out of $index\n";
print "Range begin: $file_score[$best_index][0]\n";
print "Range end: $file_score[$best_end_index-1][0]\n";
print "Range size: ", human_filesize($best_size), "\n";

my $best_midpoint = find_best_midpoint();
print "Midpoint is $best_midpoint: $file_score[$best_midpoint][0]\n";
my $best_file = $file_score[$best_midpoint][0];

print human_filesize($file_score[$best_midpoint][1]), "  $file_score[$best_midpoint][0]\n";

my $best_dir = dirname($best_file);

while($best_dir ne '/')
{
    my $best_dir_size = 0;
    for my $file_iter (@file_score)
    {
	my $name = $file_iter->[0];

	my $iter_dir = substr($name, 0, length($best_dir)+1);
	if ($iter_dir eq "$best_dir/")
	{
	    $best_dir_size += $file_iter->[1];
	}
    }

    print human_filesize($best_dir_size), "  $best_dir/\n";

    $best_dir = dirname($best_dir);
    #print "  Testing $best_dir\n";
    #print "    ", substr($file_score[$best_index][0], 0, length($best_dir)+1), " <=> ", "$best_dir/", "\n";
    #print "    ", substr($file_score[$best_end_index][0], 0, length($best_dir)+1), " <=> ", "$best_dir/", "\n";
    last if $best_end_index >= $index;
    last if substr($file_score[$best_index][0], 0, length($best_dir)+1) eq "$best_dir/" and
	substr($file_score[$best_end_index][0], 0, length($best_dir)+1) eq "$best_dir/";
    #print "    passed\n";
}

$file_history{$best_file} = time();

untie(%file_history);
